//! Стрілочні функції (Arrow function expressions)
//* Стрілочні функції мають скорочений, лаконічніший синтаксис, що зменшує обсяг коду,
//* особливо коли функція маленька або якщо вона використовується як колбек.

//* Усі стрілки створюються як функціональний вираз, і якщо функція - не анонімна, її необхідно присвоювати змінній.

// Звичайне оголошення функції

function classicAdd(a, b, c) {
  return a + b + c;
}

// Те саме стрілочною функцією

// EXP 1 - Повний запис

// const arrowAdd = (a, b, c) => {
//   return a + b + c;
// };

// EXP 2 - Короткий запис

// const arrowAdd = (a, b, c) => a + b + c;

// console.log(classicAdd(1, 2, 3));
// console.log(arrowAdd(1, 2, 3));

//? Ключове слово function не використовується, замість цього відразу зазначається оголошення параметрів, після нього - символ => і тіло функції.

//? Якщо параметрів декілька, то вони перераховуються через кому в круглих дужках, між знаками дорівнює = і стрілкою =>.

// const add = (a, b, c) => {
//   return a + b + c;
// };

//? Якщо параметр один, його можна оголошувати без круглих дужок.

// const add = a => {
//   return a + 5;
// };

//? Якщо параметри відсутні, то обов'язково повинні бути порожні круглі дужки.

// const greet = () => {
//   console.log("Привіт!");
// };

//! Неявне повернення
//? У стрілочної функції після символу => знаходиться її тіло. Існує два варіанти: з фігурними дужками і без них.

//* EXP 1 - Явне повернення (explicit return)
// Якщо є фігурні дужки, і функція повинна повертати якесь значення, необхідно явно поставити return.
// Це називається явне повернення(explicit return). Такий синтаксис використовується у разі,
// якщо в тілі функції потрібно виконати ще якісь інструкції, крім повернення значення.

// const addExplicit = (a, b, c) => {
//   console.log(a, b, c);
//   return a + b + c;
// };

// console.log(addExplicit(1, 2, 3));

//* EXP 2 - Неявне повернення (implicit return)
// Якщо фігурні дужки відсутні, то повертається результат виразу, який стоїть після =>.
// Це називається неявне повернення(implicit return). У прикладі повернеться результат виразу додавання параметрів a, b і c.

// const addImplicit = (a, b, c) => a + b + c;

// console.log(addImplicit(2, 3, 4));

// Синтаксис неявного повернення суттєво скорочує «шум» оголошення функції з тілом і виразом, що повертається,
// але доречний тільки тоді, коли в тілі функції не потрібно виконувати жодних додаткових інструкцій, крім повернення значення.

// // До
// function classicAdd(a, b, c) {
//   return a + b + c;
// }

// // Після
// const arrowAdd = (a, b, c) => a + b + c;


//! Псевдомасив arguments
//? У стрілочних функцій немає локальної змінної arguments, що містить усі аргументи.
//? Якщо необхідно зібрати всі аргументи в масив, використовується операція rest.

// const add = (...args) => {
//   console.log(args);
// };

// add(1, 2, 3); // [1, 2, 3]

//! Стрілочні функції як колбеки
//* Анонімні стрілочні функції відмінно підходять як колбеки для перебираючих методів масиву завдяки коротшому синтаксису оголошення,
//* особливо, якщо не потрібне тіло функції.

// const numbers = [5, 10, 15, 20, 25];

// Оголошення функції
// numbers.forEach(function (number, index) {
//   console.log(`Індекс ${index}, значення ${number}`);
// });

// Анонімна стрілочна функція
// numbers.forEach((number, index) => {
//   console.log(`Індекс ${index}, значення ${number}`);
// });

//* Стрілочну колбек - функцію також можна оголошувати окремо і передавати на неї посилання.
//* Це варто робити, якщо одна функція використовується у декількох місцях програми або якщо вона громіздка.

const numbers = [5, 10, 15, 20, 25];

const logMessage = (number, index) => {
  console.log(`Індекс ${index}, значення ${number}`);
};

numbers.forEach(logMessage);